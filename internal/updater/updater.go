package updater

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"warike/base/internal/providers"
)

type Updater struct {
	Client *providers.Client
}

func NewUpdater() *Updater {
	return &Updater{
		Client: providers.NewClient(),
	}
}

type ProviderInfo struct {
	Name    string
	Source  string
	Version string
}

func (u *Updater) ParseProviderFile(path string) ([]ProviderInfo, string, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		return nil, "", err
	}

	contentStr := string(content)
	var foundProviders []ProviderInfo

	// Regex to find providers in required_providers block
	// This is a simplified regex and assumes standard formatting
	// Ideally we would use hcl parser but for this task regex is sufficient per requirements
	// Matches: aws = { source = "hashicorp/aws", version = "..." }
	// Or more generically: name = { ... source = "..." ... version = "..." ... }
	
	// Let's iterate line by line for simplicity or use a multi-line regex
	// Capture source and version
	// Assumption: source and version are on separate lines inside the block
	
	// Let's try to match: source\s*=\s*"([^"]+)" and version\s*=\s*"([^"]+)"
	// But we need to group them.
	
	// Simplistic approach: Find all blocks.
	// Since we need to update the file later, simple string replacement might be best 
	// if we can identify unique signatures.
	
	reSource := regexp.MustCompile(`source\s*=\s*"([^"]+)"`)
	reVersion := regexp.MustCompile(`version\s*=\s*"([^"]+)"`)
	
	// This is tricky without a full parser. 
	// Let's assume the file format generated by our tool:
	/*
	    aws = {
	      source  = "hashicorp/aws"
	      version = "5.30.0"
	    }
	*/
	
	lines := strings.Split(contentStr, "\n")
	var currentSource string
	
	for _, line := range lines {
		if match := reSource.FindStringSubmatch(line); len(match) > 1 {
			currentSource = match[1]
		}
		if match := reVersion.FindStringSubmatch(line); len(match) > 1 && currentSource != "" {
			// Found a pair
			// Note: This relies on source coming before version or close to it.
			// And doesn't capture the name "aws" easily without more context.
			// But we really just need source and version to check updates.
			
			foundProviders = append(foundProviders, ProviderInfo{
				Source:  currentSource,
				Version: match[1],
			})
			currentSource = "" // Reset
		}
	}
	
	return foundProviders, contentStr, nil
}

func (u *Updater) UpdateProject(dirName string) ([]string, error) {
	providerPath := filepath.Join(dirName, "provider.tf")
	if _, err := os.Stat(providerPath); os.IsNotExist(err) {
		return nil, fmt.Errorf("provider.tf not found in %s", dirName)
	}

	providersList, content, err := u.ParseProviderFile(providerPath)
	if err != nil {
		return nil, err
	}

	var updates []string
	newContent := content

	for _, p := range providersList {
		latest, err := u.Client.GetLatestVersion(p.Source)
		if err != nil {
			// Log error but continue? Or fail?
			// For CLI, maybe return error
			return nil, fmt.Errorf("failed to check update for %s: %w", p.Source, err)
		}

		if latest != p.Version {
			updates = append(updates, fmt.Sprintf("Updated %s from %s to %s", p.Source, p.Version, latest))
			// Replace version in content
			// Be careful to replace only the specific version associated with this source
			// This regex replacement is naive and might replace other occurrences
			// A better way is to construct the old string 'version = "old"' and new 'version = "new"'
			// but indentation matters.
			
			// Let's do a scoped replacement if possible, or just global for that version string
			// if it's unique enough.
			// Risk: Two providers having same version.
			
			// Better: Replace exact line.
			// re := regexp.MustCompile(fmt.Sprintf(`version\s*=\s*"%s"`, regexp.QuoteMeta(p.Version)))
			// But we need to make sure it's for the right provider.
			
			// For this MVP refactor, we'll assume we replace the specific line following the source.
			
			// Let's traverse lines again to reconstruct
			lines := strings.Split(newContent, "\n")
			var outLines []string
			var pendingSource string
			
			for _, line := range lines {
				if match := regexp.MustCompile(`source\s*=\s*"([^"]+)"`).FindStringSubmatch(line); len(match) > 1 {
					if match[1] == p.Source {
						pendingSource = p.Source
					}
				}
				
				if pendingSource == p.Source {
					if strings.Contains(line, fmt.Sprintf(`version = "%s"`, p.Version)) {
						line = strings.Replace(line, p.Version, latest, 1)
						pendingSource = "" // Done for this block
					}
				}
				outLines = append(outLines, line)
			}
			newContent = strings.Join(outLines, "\n")
		}
	}

	if len(updates) > 0 {
		if err := os.WriteFile(providerPath, []byte(newContent), 0644); err != nil {
			return nil, err
		}
	}

	return updates, nil
}
